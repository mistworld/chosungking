// ============================================
// Dashboardì—ì„œ ì‚¬ìš©í•  í†µí•© Worker íŒŒì¼
// ============================================

const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, DELETE, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type',
};

// ============================================
// Durable Object: GameStateRoom
// ============================================

export class GameStateRoom {
    constructor(state, env) {
        this.state = state;
        this.env = env;
        this.roomStatePromise = null;
    }

    async fetch(request) {
        if (request.method === 'OPTIONS') {
            return new Response(null, { headers: corsHeaders });
        }

        const url = new URL(request.url);
        const roomId = url.searchParams.get('roomId');

        if (!roomId) {
            return this.json({ error: 'roomId is required' }, 400);
        }

        if (request.method === 'GET') {
            const snapshot = await this.getState();
            if (!snapshot) {
                return this.json({ error: 'Room not found' }, 404);
            }
            return this.json(snapshot);
        }

        if (request.method === 'POST') {
            const body = await request.json();
            const updated = await this.state.blockConcurrencyWhile(() =>
                this.applyUpdate(roomId, body)
            );
            return this.json(updated);
        }

        if (request.method === 'DELETE') {
            await this.state.blockConcurrencyWhile(async () => {
                await this.state.storage.deleteAll();
                this.roomStatePromise = Promise.resolve(null);
            });
            return this.json({ success: true });
        }

        return this.json({ error: 'Method not allowed' }, 405);
    }

    async alarm() {
        await this.state.storage.deleteAll();
        this.roomStatePromise = Promise.resolve(null);
    }

    async applyUpdate(roomId, update) {
        const state = await this.ensureState(roomId);
        const now = Date.now();

        // ğŸ†• í„´ì œ ëª¨ë“œì—ì„œ state.playersê°€ ì—†ê±°ë‚˜ ë¹„ì–´ìˆìœ¼ë©´ update.playersë¡œ ì´ˆê¸°í™” (ê²Œì„ ì‹œì‘ í›„ players ì •ë³´ ìœ ì§€)
        if (state.gameMode === 'turn' && Array.isArray(update.players) && update.players.length > 0) {
            if (!state.players || state.players.length === 0) {
                // state.playersê°€ ì—†ìœ¼ë©´ update.playersë¡œ ì´ˆê¸°í™”
                state.players = update.players;
                console.log(`[í„´ì œ] state.players ì´ˆê¸°í™”: ${state.players.map(p => p.id || p).join(', ')}`);
            } else if (update.players.length > state.players.length) {
                // update.playersê°€ ë” ë§ìœ¼ë©´ ì—…ë°ì´íŠ¸ (ìƒˆ í”Œë ˆì´ì–´ ì¶”ê°€ë¨)
                state.players = update.players;
                console.log(`[í„´ì œ] state.players ì—…ë°ì´íŠ¸ (ìƒˆ í”Œë ˆì´ì–´ ì¶”ê°€): ${state.players.map(p => p.id || p).join(', ')}`);
            }
            // state.playersê°€ ì´ë¯¸ ìˆê³  ë” ë§ìœ¼ë©´ ìœ ì§€ (ì„œë²„ê°€ source of truth)
        }

        if (update.playerId && update.score !== undefined) {
            state.scores[update.playerId] = update.score;
            state.playerWords[update.playerId] = update.words || [];
            state.lastUpdate = now;
        }

        // ì±„íŒ… ë©”ì‹œì§€ ì¶”ê°€
        if (update.chatMessage && update.playerName) {
            if (!state.chatMessages) {
                state.chatMessages = [];
            }
            state.chatMessages.push({
                playerId: update.playerId,
                playerName: update.playerName,
                message: update.chatMessage,
                timestamp: now
            });
            // ìµœëŒ€ 100ê°œ ë©”ì‹œì§€ë§Œ ìœ ì§€
            if (state.chatMessages.length > 100) {
                state.chatMessages = state.chatMessages.slice(-100);
            }
        }

        if (update.action === 'start_game') {
            state.gameStarted = true;
            state.startTime = now; // í•­ìƒ ì„œë²„ ì‹œê°„ ì‚¬ìš© (í´ë¼ì´ì–¸íŠ¸ ì‹œê°„ ë¬´ì‹œ)
            state.timeLeft = 180; // í•­ìƒ 180ì´ˆë¡œ ì´ˆê¸°í™”
            state.consonants = update.consonants || state.consonants || [];
            state.endTime = null;
            state.roundNumber += 1;
            
            // ğŸ†• í„´ì œ ëª¨ë“œ ì´ˆê¸°í™”
            if (update.gameMode === 'turn') {
                state.gameMode = 'turn';
                state.usedWords = [];
                state.playerLives = {};
                state.eliminatedPlayers = [];
                state.turnCount = {};
                state.isFirstTurn = true;
                
                // ğŸ§  í”Œë ˆì´ì–´ ìˆœì„œëŠ” ì„œë²„(state.players)ì—ë§Œ ì €ì¥í•˜ê³  ì‚¬ìš©
                if (Array.isArray(update.players) && update.players.length > 0) {
                    state.players = update.players;
                }
                
                // ì²« ë²ˆì§¸ í”Œë ˆì´ì–´(ë°©ì¥)ì˜ í„´ ì‹œì‘
                const players = state.players || [];
                if (players.length > 0) {
                    const firstPlayer = players[0];
                    state.currentTurnPlayerId = firstPlayer.id;
                    state.turnStartTime = now;
                    state.playerLives[firstPlayer.id] = 0;
                    state.turnCount[firstPlayer.id] = 0;
                } else {
                    state.currentTurnPlayerId = update.hostPlayerId || null;
                    state.turnStartTime = now;
                }
            }
            
            await this.state.storage.deleteAlarm();
        }

        if (update.action === 'new_game') {
            state.gameStarted = true;
            state.startTime = now;
            state.timeLeft = 180;
            state.consonants = update.consonants || [];
            state.endTime = null;
            state.scores = {};
            state.playerWords = {};
            state.roundNumber += 1;
            
            // ğŸ†• í„´ì œ ëª¨ë“œ ì´ˆê¸°í™”
            if (update.gameMode === 'turn' || state.gameMode === 'turn') {
                state.gameMode = 'turn';
                state.usedWords = [];
                state.playerLives = {};
                state.eliminatedPlayers = [];
                state.turnCount = {};
                state.isFirstTurn = true;
                
                // ğŸ§  í”Œë ˆì´ì–´ ìˆœì„œëŠ” ì„œë²„(state.players)ì—ë§Œ ì €ì¥í•˜ê³  ì‚¬ìš©
                if (Array.isArray(update.players) && update.players.length > 0) {
                    state.players = update.players;
                }
                
                // ì²« ë²ˆì§¸ í”Œë ˆì´ì–´(ë°©ì¥)ì˜ í„´ ì‹œì‘
                const players = state.players || [];
                if (players.length > 0) {
                    const firstPlayer = players[0];
                    state.currentTurnPlayerId = firstPlayer.id;
                    state.turnStartTime = now;
                    state.playerLives[firstPlayer.id] = 0;
                    state.turnCount[firstPlayer.id] = 0;
                } else {
                    state.currentTurnPlayerId = update.hostPlayerId || state.currentTurnPlayerId || null;
                    state.turnStartTime = now;
                }
            }
            
            // ì±„íŒ… ë©”ì‹œì§€ëŠ” ìœ ì§€ (ê²Œì„ ëë‚˜ê³  ì±„íŒ…í•  ìˆ˜ ìˆë„ë¡)
            await this.state.storage.deleteAlarm();
        }

        // ğŸ†• í„´ì œ ëª¨ë“œ: ë‹¨ì–´ ì…ë ¥ ì²˜ë¦¬
        if (update.action === 'submit_word' && state.gameMode === 'turn') {
            const { playerId, word, isValid, wordLength, hasSpecialConsonant } = update;
            
            // í˜„ì¬ í„´ì¸ì§€ í™•ì¸
            if (playerId !== state.currentTurnPlayerId) {
                console.log(`[í„´ì œ] ${playerId}ëŠ” í˜„ì¬ í„´ì´ ì•„ë‹™ë‹ˆë‹¤. í˜„ì¬ í„´: ${state.currentTurnPlayerId}`);
                return state;
            }
            
            // ğŸ†• ì‹œê°„ ì´ˆê³¼ ì²´í¬ (ì„œë²„ ì¸¡ì—ì„œë„ í™•ì¸)
            if (state.turnStartTime) {
                const turnTimeLimit = state.isFirstTurn ? 9000 : 6000; // ì²« í„´ 9ì´ˆ, ì´í›„ 6ì´ˆ (ë°€ë¦¬ì´ˆ)
                const elapsed = now - state.turnStartTime;
                
                if (elapsed >= turnTimeLimit) {
                    // ì‹œê°„ ì´ˆê³¼: ë‹¨ì–´ë¥¼ ê±°ë¶€í•˜ê³  turn_timeout ì²˜ë¦¬
                    console.log(`[í„´ì œ] ${playerId} ì‹œê°„ ì´ˆê³¼ (${elapsed}ms >= ${turnTimeLimit}ms). ë‹¨ì–´ ê±°ë¶€`);
                    
                    // ì—°ì¥ê¶Œ ì†Œì§„
                    if (!state.playerLives[playerId]) state.playerLives[playerId] = 0;
                    state.playerLives[playerId] -= 1;
                    
                    if (state.playerLives[playerId] < 0) {
                        // íƒˆë½
                        if (!state.eliminatedPlayers.includes(playerId)) {
                            state.eliminatedPlayers.push(playerId);
                            console.log(`[í„´ì œ] ${playerId} íƒˆë½!`);
                        }
                        
                        // í™œì„± í”Œë ˆì´ì–´ê°€ 1ëª… ë‚¨ìœ¼ë©´ ê²Œì„ ì¢…ë£Œ
                        // ğŸ†• í•­ìƒ ì„œë²„ state.playersë§Œ ì‚¬ìš© (í´ë¼ì´ì–¸íŠ¸ì—ì„œ ë³´ë‚¸ players ë¬´ì‹œ)
                        const activePlayers = (state.players || []).filter(p => !state.eliminatedPlayers.includes(p.id));
                        if (activePlayers.length <= 1) {
                            state.gameStarted = false;
                            state.endTime = now;
                            return state;
                        }
                        
                        // ë‹¤ìŒ í„´ìœ¼ë¡œ ì „í™˜ (state.playersë§Œ ì‚¬ìš©)
                        await this.nextTurn(state, now, state.players || []);
                    } else {
                        // ì—°ì¥ê¶Œì´ ë‚¨ì•„ìˆìœ¼ë©´ ë‹¤ìŒ 6ì´ˆ ì‹œì‘
                        state.turnStartTime = now;
                        console.log(`[í„´ì œ] ${playerId} ì—°ì¥ê¶Œ ì‚¬ìš©. ë‹¤ìŒ 6ì´ˆ ì‹œì‘`);
                    }
                    
                    return state; // ë‹¨ì–´ ê±°ë¶€
                }
            }
            
            if (isValid) {
                // ì¤‘ë³µ ì²´í¬
                const wordLower = word.toLowerCase();
                if (state.usedWords.includes(wordLower)) {
                    // ì¤‘ë³µ ë‹¨ì–´ëŠ” ì˜¤ë‹µ ì²˜ë¦¬ (íƒˆë½ì€ ì•„ë‹ˆì§€ë§Œ ì¸ì • ì•ˆë¨)
                    console.log(`[í„´ì œ] ì¤‘ë³µ ë‹¨ì–´: ${wordLower}`);
                    return state;
                }
                
                // ë‹¨ì–´ ì¶”ê°€
                state.usedWords.push(wordLower);
                
                // í„´ íšŸìˆ˜ ì¦ê°€
                if (!state.turnCount[playerId]) state.turnCount[playerId] = 0;
                state.turnCount[playerId] += 1;
                
                // ì—°ì¥ê¶Œ ê³„ì‚°
                let livesEarned = 0;
                if (wordLength === 2 && hasSpecialConsonant) {
                    livesEarned = 1; // 2ê¸€ì + íŠ¹ë³„ì´ˆì„±
                } else if (wordLength === 2) {
                    livesEarned = 0; // 2ê¸€ì ì¼ë°˜
                } else if (wordLength === 3) {
                    livesEarned = 1; // 3ê¸€ì
                } else if (wordLength === 4) {
                    livesEarned = 3; // 4ê¸€ì
                } else if (wordLength >= 5) {
                    livesEarned = 5; // 5ê¸€ì+
                }
                
                // ì—°ì¥ê¶Œ ì¶”ê°€
                if (!state.playerLives[playerId]) state.playerLives[playerId] = 0;
                state.playerLives[playerId] += livesEarned;
                
                console.log(`[í„´ì œ] ${playerId}ê°€ "${word}" ë§ì¶¤. ì—°ì¥ê¶Œ +${livesEarned}, í˜„ì¬: ${state.playerLives[playerId]}`);
                
                // ì¦‰ì‹œ ë‹¤ìŒ í„´ìœ¼ë¡œ ì „í™˜
                // ğŸ§  í•­ìƒ ì„œë²„ì— ì €ì¥ëœ í”Œë ˆì´ì–´ ìˆœì„œ(state.players)ë§Œ ì‚¬ìš©
                await this.nextTurn(state, now, state.players || []);
            }
        }
        
        // ğŸ†• í„´ì œ ëª¨ë“œ: í„´ ì‹œê°„ ì´ˆê³¼ ì²˜ë¦¬
        if (update.action === 'turn_timeout' && state.gameMode === 'turn') {
            const { playerId } = update;
            if (playerId === state.currentTurnPlayerId) {
                // ì—°ì¥ê¶Œ ì†Œì§„ (6ì´ˆ ë‹¨ìœ„)
                if (!state.playerLives[playerId]) state.playerLives[playerId] = 0;
                state.playerLives[playerId] -= 1;
                
                console.log(`[í„´ì œ] ${playerId} ì‹œê°„ ì´ˆê³¼. ì—°ì¥ê¶Œ -1, í˜„ì¬: ${state.playerLives[playerId]}`);
                
                if (state.playerLives[playerId] < 0) {
                    // ì—°ì¥ê¶Œì´ 0 ì´í•˜ê°€ ë˜ë©´ íƒˆë½
                    if (!state.eliminatedPlayers.includes(playerId)) {
                        state.eliminatedPlayers.push(playerId);
                        console.log(`[í„´ì œ] ${playerId} íƒˆë½!`);
                    }
                    
                    // í™œì„± í”Œë ˆì´ì–´ê°€ 1ëª… ë‚¨ìœ¼ë©´ ê²Œì„ ì¢…ë£Œ
                    // ğŸ†• í•­ìƒ ì„œë²„ state.playersë§Œ ì‚¬ìš©
                    const activePlayers = (state.players || []).filter(p => !state.eliminatedPlayers.includes(p.id));
                    if (activePlayers.length <= 1) {
                        state.gameStarted = false;
                        state.endTime = now;
                        return state;
                    }
                    
                    // ë‹¤ìŒ í„´ìœ¼ë¡œ ì „í™˜ (state.playersë§Œ ì‚¬ìš©)
                    await this.nextTurn(state, now, state.players || []);
                } else {
                    // ì—°ì¥ê¶Œì´ ë‚¨ì•„ìˆìœ¼ë©´ ë‹¤ìŒ 6ì´ˆ ì‹œì‘
                    state.turnStartTime = now;
                    console.log(`[í„´ì œ] ${playerId} ì—°ì¥ê¶Œ ì‚¬ìš©. ë‹¤ìŒ 6ì´ˆ ì‹œì‘`);
                }
            }
        }

        // ğŸ†• íƒˆë½ì ì¬ì…ì¥ ì²˜ë¦¬: ê°™ì€ ë¼ìš´ë“œì—ì„œ ì¬ì…ì¥ ì‹œ eliminatedPlayersì— ë‹¤ì‹œ ì¶”ê°€
        if (update.action === 'player_rejoin' && state.gameMode === 'turn') {
            const { playerId } = update;
            if (playerId && state.eliminatedPlayers && !state.eliminatedPlayers.includes(playerId)) {
                // íƒˆë½ìê°€ ì¬ì…ì¥í•˜ëŠ” ê²½ìš°: eliminatedPlayersì— ë‹¤ì‹œ ì¶”ê°€
                state.eliminatedPlayers.push(playerId);
                console.log(`[í„´ì œ] íƒˆë½ì ${playerId} ì¬ì…ì¥ - eliminatedPlayersì— ë‹¤ì‹œ ì¶”ê°€`);
            }
        }

        if (update.action === 'end_game') {
            state.gameStarted = false;
            state.endTime = now;
            await this.state.storage.setAlarm(now + 60 * 1000);
        }

        await this.persistState(state);
        return state;
    }

    async ensureState(roomId) {
        let snapshot = await this.getState();
        if (!snapshot) {
            snapshot = {
                id: roomId,
                createdAt: Date.now(),
                gameStarted: false,
                startTime: null,
                endTime: null,
                timeLeft: 180,
                consonants: [],
                scores: {},
                playerWords: {},
                roundNumber: 0,
                lastUpdate: null,
                chatMessages: [], // ì±„íŒ… ë©”ì‹œì§€ ë°°ì—´ ì¶”ê°€
                // ğŸ†• í„´ì œ ëª¨ë“œ ìƒíƒœ
                gameMode: 'time', // 'time' or 'turn'
                currentTurnPlayerId: null,
                turnStartTime: null,
                playerLives: {}, // { playerId: ì—°ì¥ê¶Œ ê°œìˆ˜ }
                eliminatedPlayers: [], // íƒˆë½í•œ í”Œë ˆì´ì–´ ID ëª©ë¡
                usedWords: [], // ì „ì²´ ì‚¬ìš©ëœ ë‹¨ì–´ ëª©ë¡ (ì¤‘ë³µ ì²´í¬ìš©)
                turnCount: {}, // { playerId: í„´ íšŸìˆ˜ }
                isFirstTurn: true // ì²« í„´ ì—¬ë¶€ (9ì´ˆ vs 6ì´ˆ)
            };
            await this.persistState(snapshot);
        }
        // ê¸°ì¡´ ìƒíƒœì— chatMessagesê°€ ì—†ìœ¼ë©´ ì´ˆê¸°í™”
        if (!snapshot.chatMessages) {
            snapshot.chatMessages = [];
        }
        // ğŸ†• ê¸°ì¡´ ìƒíƒœì— í„´ì œ í•„ë“œê°€ ì—†ìœ¼ë©´ ì´ˆê¸°í™”
        if (!snapshot.gameMode) snapshot.gameMode = 'time';
        if (!snapshot.playerLives) snapshot.playerLives = {};
        if (!snapshot.eliminatedPlayers) snapshot.eliminatedPlayers = [];
        if (!snapshot.usedWords) snapshot.usedWords = [];
        if (!snapshot.turnCount) snapshot.turnCount = {};
        if (snapshot.isFirstTurn === undefined) snapshot.isFirstTurn = true;
        return snapshot;
    }

    async getState() {
        if (!this.roomStatePromise) {
            this.roomStatePromise = this.state.storage.get('roomState');
        }
        return this.roomStatePromise;
    }

    async persistState(state) {
        this.roomStatePromise = Promise.resolve(state);
        await this.state.storage.put('roomState', state);
    }

    // ğŸ†• í„´ì œ ëª¨ë“œ: ë‹¤ìŒ í„´ìœ¼ë¡œ ì „í™˜
    async nextTurn(state, now, players = []) {
        // ğŸ†• í•­ìƒ state.playersë¥¼ ìš°ì„  ì‚¬ìš© (ì—†ìœ¼ë©´ ì „ë‹¬ë°›ì€ players ì‚¬ìš©)
        let playerList = state.players || [];
        if (playerList.length === 0 && players.length > 0) {
            // state.playersê°€ ì—†ìœ¼ë©´ ì „ë‹¬ë°›ì€ players ì‚¬ìš©í•˜ê³  ì €ì¥
            playerList = players;
            state.players = players;
            console.log(`[í„´ì œ] nextTurn: state.players ì—†ì–´ì„œ ì „ë‹¬ë°›ì€ players ì‚¬ìš©: ${players.map(p => p.id || p).join(', ')}`);
        }
        
        if (playerList.length === 0) {
            console.log('[í„´ì œ] nextTurn: players ë°°ì—´ì´ ë¹„ì–´ìˆìŒ - ê²Œì„ ì¢…ë£Œ');
            state.gameStarted = false;
            state.endTime = now;
            return;
        }
        
        console.log('[í„´ì œ] nextTurn í˜¸ì¶œ:', {
            currentTurn: state.currentTurnPlayerId,
            players: playerList.map(p => p.id),
            eliminated: state.eliminatedPlayers
        });
        
        // íƒˆë½í•˜ì§€ ì•Šì€ í”Œë ˆì´ì–´ë§Œ í•„í„°ë§
        const activePlayers = playerList.filter(p => !state.eliminatedPlayers.includes(p.id));
        if (activePlayers.length <= 1) {
            // 1ëª…ë§Œ ë‚¨ìœ¼ë©´ ê²Œì„ ì¢…ë£Œ
            state.gameStarted = false;
            state.endTime = now;
            return;
        }
        
        // í˜„ì¬ í„´ í”Œë ˆì´ì–´ì˜ ì¸ë±ìŠ¤ ì°¾ê¸°
        const currentIndex = activePlayers.findIndex(p => p.id === state.currentTurnPlayerId);
        if (currentIndex === -1) {
            // í˜„ì¬ í„´ í”Œë ˆì´ì–´ê°€ ì—†ìœ¼ë©´ ì²« ë²ˆì§¸ í”Œë ˆì´ì–´ë¡œ ì„¤ì •
            state.currentTurnPlayerId = activePlayers[0].id;
            state.turnStartTime = now;
            state.isFirstTurn = true;
            return;
        }
        
        const nextIndex = (currentIndex + 1) % activePlayers.length;
        const nextPlayer = activePlayers[nextIndex];
        
        // ë‹¤ìŒ í„´ìœ¼ë¡œ ì „í™˜
        state.currentTurnPlayerId = nextPlayer.id;
        state.turnStartTime = now;
        state.isFirstTurn = false; // ì²« í„´ì´ ì•„ë‹ˆë©´ 6ì´ˆ

        // ë‹¤ìŒ í”Œë ˆì´ì–´ì˜ ì—°ì¥ê¶Œ/í„´íšŸìˆ˜ ì´ˆê¸°í™” (ì—†ìœ¼ë©´)
        if (state.playerLives[nextPlayer.id] === undefined) {
            state.playerLives[nextPlayer.id] = 0;
        }
        if (state.turnCount[nextPlayer.id] === undefined) {
            state.turnCount[nextPlayer.id] = 0;
        }
    }

    json(payload, status = 200) {
        return new Response(JSON.stringify(payload), {
            status,
            headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
    }
}

// ============================================
// Main Worker API Handlers
// ============================================

async function handleRooms(env) {
    const corsHeadersWithCache = {
        ...corsHeaders,
        'Cache-Control': 'no-cache, no-store, must-revalidate'
    };

    // ìµœê·¼ì— í´ë§í•œ í”Œë ˆì´ì–´ë§Œ "ì ‘ì† ì¤‘"ìœ¼ë¡œ ì¸ì •í•˜ëŠ” ê¸°ì¤€ ì‹œê°„
    const STALE_PLAYER_TIMEOUT = 5 * 1000; // 5ì´ˆ

    try {
        if (!env.ROOM_LIST) {
            console.log('ROOM_LISTê°€ ì—†ìŒ!');
            return new Response(JSON.stringify([]), {
                headers: { 
                    'Content-Type': 'application/json',
                    ...corsHeadersWithCache 
                }
            });
        }

        const now = Date.now();
        const ONE_HOUR = 60 * 60 * 1000;
        const rooms = [];
        const seenIds = new Set(); // ì¤‘ë³µ ë°© ë°©ì§€
        const roomIdSet = new Set(); // ì²˜ë¦¬í•œ ë°© ID ì¶”ì 

        // 1) list()ë¡œ ê¸°ì¡´ ë°© ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
        const list = await env.ROOM_LIST.list({ limit: 100 });
        console.log(`[rooms] list() ê²°ê³¼: ${list.keys.length}ê°œ`);
        
        // 2) ìµœê·¼ ìƒì„±ëœ ë°© ëª©ë¡ë„ ê°€ì ¸ì˜¤ê¸° (KV eventual consistency ëŒ€ì‘)
        const recentRooms = await env.ROOM_LIST.get('_recent_rooms', 'json') || [];
        const recentRoomIds = new Set(recentRooms.map(r => r.roomId));
        console.log(`[rooms] ìµœê·¼ ìƒì„±ëœ ë°©: ${recentRoomIds.size}ê°œ`);
        
        // KV ì½ê¸°ë¥¼ ë³‘ë ¬ë¡œ ìˆ˜í–‰
        const roomPromises = list.keys.map(key => env.ROOM_LIST.get(key.name, 'json'));
        const roomDataArray = await Promise.all(roomPromises);
        
        // ìµœê·¼ ìƒì„±ëœ ë°© ì¤‘ list()ì— ì—†ëŠ” ê²ƒë„ ì¶”ê°€ë¡œ ì¡°íšŒ
        const recentRoomPromises = Array.from(recentRoomIds)
            .filter(id => !list.keys.some(k => k.name === id))
            .map(id => env.ROOM_LIST.get(id, 'json'));
        const recentRoomDataArray = await Promise.all(recentRoomPromises);
        
        // list() ê²°ê³¼ ì²˜ë¦¬
        for (let i = 0; i < list.keys.length; i++) {
            const key = list.keys[i];
            try {
                const roomData = roomDataArray[i];

                // KVì— ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ì˜¤ë˜ëœ í‚¤ì´ë¯€ë¡œ ê±´ë„ˆëœ€
                if (!roomData) {
                    console.log(`roomData ì—†ìŒ, í‚¤ ì œê±° ëŒ€ìƒ: ${key.name}`);
                    continue;
                }

                const createdAt = roomData.createdAt || now;
                const roomId = roomData.id || key.name;
                const players = Array.isArray(roomData.players) ? roomData.players : [];
                
                // ê¸°ë³¸ê°’: players.length
                let playerCount = players.length;
                
                // lastSeenì´ ìˆìœ¼ë©´ ì‹¤ì œ ì ‘ì† ì¤‘ì¸ ì‚¬ëŒë§Œ ì„¸ê¸° (ìœ ë ¹ë°© í•„í„°ë§)
                if (roomData.lastSeen && typeof roomData.lastSeen === 'object' && players.length > 0) {
                    const activePlayers = players.filter(p => {
                        const last = roomData.lastSeen[p.id];
                        // lastSeenì´ ì—†ìœ¼ë©´ í™œì„±ìœ¼ë¡œ ê°„ì£¼ (ë°©ê¸ˆ ì…ì¥í–ˆì„ ìˆ˜ ìˆìŒ)
                        // lastSeenì´ ìˆìœ¼ë©´ 5ì´ˆ ì´ë‚´ì— í´ë§í•œ ì‚¬ëŒë§Œ í™œì„±
                        return !last || (typeof last === 'number' && (now - last) < STALE_PLAYER_TIMEOUT);
                    });
                    playerCount = activePlayers.length;
                }
                // lastSeenì´ ì—†ìœ¼ë©´ players.length ì‚¬ìš© (ì˜ˆì „ ë°ì´í„°ì´ê±°ë‚˜ ë°©ê¸ˆ ë§Œë“  ë°©)

                // 1ì‹œê°„ì´ ì§€ë‚œ ë°©ì€ ëª©ë¡ì—ì„œ ì œì™¸ (ì²­ì†Œ ìš©ë„)
                if ((now - createdAt) >= ONE_HOUR) {
                    continue;
                }

                // í”Œë ˆì´ì–´ê°€ í•œ ëª…ë„ ì—†ìœ¼ë©´ ëª©ë¡ì—ì„œ ì œì™¸
                if (playerCount <= 0) {
                    continue;
                }

                // ì¤‘ë³µ id ë°©ì§€
                if (seenIds.has(roomId)) {
                    continue;
                }
                seenIds.add(roomId);

                // rooms ë°°ì—´ì— ì¶”ê°€ (roomNumber í¬í•¨)
                rooms.push({
                    id: roomId,
                    roomNumber: roomData.roomNumber || 0,
                    createdAt,
                    title: roomData.title || 'ì´ˆì„± ë°°í‹€ë°©',
                    gameMode: roomData.gameMode || 'time',
                    playerCount,
                    maxPlayers: roomData.maxPlayers || 5,
                    players: [], // í´ë¼ì´ì–¸íŠ¸ í˜¸í™˜ì„±
                    gameStarted: roomData.gameStarted || false
                });
            } catch (error) {
                console.error(`ë°© ì²˜ë¦¬ ì‹¤íŒ¨ ${key.name}:`, error);
            }
        }
        
        // ìµœê·¼ ìƒì„±ëœ ë°© ì¤‘ list()ì— ì—†ì—ˆë˜ ê²ƒë„ ì²˜ë¦¬
        for (const roomData of recentRoomDataArray) {
            if (!roomData) continue;
            const roomId = roomData.id;
            if (seenIds.has(roomId)) continue; // ì´ë¯¸ ì²˜ë¦¬í•œ ë°©ì€ ìŠ¤í‚µ
            
            try {
                const createdAt = roomData.createdAt || now;
                const players = Array.isArray(roomData.players) ? roomData.players : [];
                
                let playerCount = players.length;
                
                if (roomData.lastSeen && typeof roomData.lastSeen === 'object' && players.length > 0) {
                    const activePlayers = players.filter(p => {
                        const last = roomData.lastSeen[p.id];
                        return !last || (typeof last === 'number' && (now - last) < STALE_PLAYER_TIMEOUT);
                    });
                    playerCount = activePlayers.length;
                }
                
                if ((now - createdAt) >= ONE_HOUR) continue;
                if (playerCount <= 0) continue;
                
                seenIds.add(roomId);
                rooms.push({
                    id: roomId,
                    roomNumber: roomData.roomNumber || 0,
                    createdAt,
                    title: roomData.title || 'ì´ˆì„± ë°°í‹€ë°©',
                    gameMode: roomData.gameMode || 'time',
                    playerCount,
                    maxPlayers: roomData.maxPlayers || 5,
                    players: [],
                    gameStarted: roomData.gameStarted || false
                });
            } catch (error) {
                console.error(`ìµœê·¼ ë°© ì²˜ë¦¬ ì‹¤íŒ¨ ${roomData?.id}:`, error);
            }
        }

        // ìµœì‹ ìˆœ ì •ë ¬
        rooms.sort((a, b) => b.createdAt - a.createdAt);
        
        console.log(`í™œì„± ë°© ê°œìˆ˜: ${rooms.length}`);

        return new Response(JSON.stringify(rooms), {
            headers: { 
                'Content-Type': 'application/json',
                ...corsHeadersWithCache 
            }
        });
    } catch (error) {
        console.error('rooms.js ì—ëŸ¬:', error);
        return new Response(JSON.stringify({ error: error.message }), {
            status: 500,
            headers: { 
                'Content-Type': 'application/json',
                ...corsHeadersWithCache 
            }
        });
    }
}

async function handleCreateRoom(request, env) {
    const { title, gameMode, playerId, playerName } = await request.json().catch(() => ({})); // ğŸ†• ì œëª©, ê²Œì„ ëª¨ë“œ, ë°©ì¥ ì •ë³´ ë°›ê¸°
    const now = Date.now();

    // ğŸ†• ë°©ë²ˆí˜¸: ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ê°€ì¥ ì‘ì€ ë²ˆí˜¸ í• ë‹¹ (1,2,3,... ìˆœì°¨ ë¶€ì—¬, ì¤‘ë³µ ë°©ì§€)
    let roomNumber = 1;
    try {
        const existing = await env.ROOM_LIST.list({ limit: 1000 });
        const usedNumbers = new Set();
        for (const key of existing.keys) {
            const meta = key.metadata;
            if (meta && typeof meta.roomNumber === 'number' && meta.roomNumber > 0) {
                usedNumbers.add(meta.roomNumber);
            }
        }
        // ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ê°€ì¥ ì‘ì€ ë²ˆí˜¸ ì°¾ê¸°
        while (usedNumbers.has(roomNumber)) {
            roomNumber++;
        }
    } catch (e) {
        console.error('[create-room] roomNumber ê³„ì‚° ì‹¤íŒ¨, 1ë¶€í„° ì‹œì‘:', e);
        roomNumber = 1;
    }

    const roomId = generateRoomCode();
    
    // ğŸ†• ëœë¤ ì œëª© ëª©ë¡
    const randomTitles = [
        "ì´ˆì„± ë°°í‹€ë°©",
        "ë¹ ë¥¸ ëŒ€ê²°",
        "ë„ì „! ì´ˆì„±ì™•",
        "ì¹œêµ¬ë“¤ê³¼ í•œíŒ",
        "ë‹¨ì–´ ì²œì¬ ëª¨ì—¬ë¼"
    ];
    
    // ğŸ†• ì œëª©ì´ ì—†ìœ¼ë©´ ëœë¤ ì„ íƒ
    const roomTitle = title && title.trim() ? title.trim() : randomTitles[Math.floor(Math.random() * randomTitles.length)];
    
    // ğŸ†• ê²Œì„ ëª¨ë“œ (ê¸°ë³¸ê°’: time)
    const mode = gameMode === 'turn' ? 'turn' : 'time';
    
    // ë°©ì¥ í”Œë ˆì´ì–´ ì •ë³´ (ë°© ìƒì„± ì‹œ ìë™ ì…ì¥)
    const hostPlayerId = playerId || `player_${Date.now()}`;
    const hostPlayerName = playerName || 'ë°©ì¥';
    
    const roomData = {
        id: roomId,
        roomNumber,
        createdAt: now,
        title: roomTitle, // ğŸ†• ì œëª© ì¶”ê°€
        gameMode: mode, // ğŸ†• ê²Œì„ ëª¨ë“œ ì¶”ê°€
        players: [{
            id: hostPlayerId,
            name: hostPlayerName,
            score: 0,
            joinedAt: now
        }],
        maxPlayers: 5,
        acceptingPlayers: true,
        gameStarted: false,
        roundNumber: 0,
        scores: { [hostPlayerId]: 0 },  // ë°©ì¥ ì ìˆ˜ ì´ˆê¸°í™”
        lastSeen: { [hostPlayerId]: now }  // ğŸ†• ë°© ìƒì„± ì‹œ ë°©ì¥ì˜ lastSeen ì´ˆê¸°í™”
    };
    
        // ë°© ìƒì„± ì‹œ ì¦‰ì‹œ metadata ì„¤ì • (ê°€ì§œë°© ë°©ì§€)
        // ë°©ì¥ì´ ìë™ìœ¼ë¡œ ì…ì¥í•˜ë¯€ë¡œ playerCount: 1
        await env.ROOM_LIST.put(roomId, JSON.stringify(roomData), {
            metadata: {
                id: roomId,
                roomNumber,
                createdAt: now,
                playerCount: 1,  // ë°©ì¥ ìë™ ì…ì¥ìœ¼ë¡œ 1
                gameStarted: false,
                roundNumber: 0,
                title: roomTitle, // ğŸ†• ì œëª©ë„ metadataì— ì €ì¥
                gameMode: mode // ğŸ†• ê²Œì„ ëª¨ë“œë„ metadataì— ì €ì¥
            }
        });
        
        // ğŸ†• ìµœê·¼ ìƒì„±ëœ ë°© ëª©ë¡ì— ì¶”ê°€ (KV eventual consistency ëŒ€ì‘)
        try {
            const recentRooms = await env.ROOM_LIST.get('_recent_rooms', 'json') || [];
            recentRooms.push({ roomId, createdAt: now });
            // ìµœê·¼ 20ê°œë§Œ ìœ ì§€ (ì˜¤ë˜ëœ ê²ƒ ì œê±°)
            const oneMinuteAgo = now - 60 * 1000;
            const filtered = recentRooms.filter(r => r.createdAt > oneMinuteAgo).slice(-20);
            await env.ROOM_LIST.put('_recent_rooms', JSON.stringify(filtered));
        } catch (e) {
            console.error('[create-room] recent rooms ì—…ë°ì´íŠ¸ ì‹¤íŒ¨ (ë¬´ì‹œ):', e);
        }
        
        return jsonResponse({ roomId });
}

async function handleJoinRoom(request, env) {
    const { roomId, playerId, playerName } = await request.json();
    if (!roomId || !playerId) {
        return jsonResponse({ error: 'Missing parameters' }, 400);
    }

    const roomData = await env.ROOM_LIST.get(roomId, 'json');
    if (!roomData) {
        return jsonResponse({ error: 'Room not found' }, 404);
    }
    if (roomData.players.length >= 5) {
        return jsonResponse({ error: 'Room is full' }, 400);
    }

    // ğŸ†• ë‹‰ë„¤ì„ ì¤‘ë³µ ì²´í¬: ê°™ì€ ë°©ì—ì„œ ê°™ì€ ë‹‰ë„¤ì„ ì‚¬ìš© ë¶ˆê°€
    if (playerName) {
        const duplicateName = roomData.players.find(p => 
            p.name && p.name.toLowerCase() === playerName.toLowerCase() && p.id !== playerId
        );
        if (duplicateName) {
            return jsonResponse({ 
                error: 'DUPLICATE_NAME',
                message: 'ì´ë¯¸ ê°™ì€ ë‹‰ë„¤ì„ì´ ìˆìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ì´ë¦„ìœ¼ë¡œ ë³€ê²½í•´ì£¼ì„¸ìš”.' 
            }, 400);
        }
    }

    const existingPlayer = roomData.players.find(p => p.id === playerId);
    if (!existingPlayer) {
        // ìƒˆë¡œìš´ í”Œë ˆì´ì–´ ì…ì¥
        roomData.players.push({
            id: playerId,
            name: playerName || `í”Œë ˆì´ì–´${roomData.players.length + 1}`,
            score: 0,
            joinedAt: Date.now()
        });
        roomData.scores = roomData.scores || {};
        roomData.scores[playerId] = 0;

        await env.ROOM_LIST.put(roomId, JSON.stringify(roomData), {
            metadata: {
                id: roomId,
                roomNumber: roomData.roomNumber || 0,
                createdAt: roomData.createdAt,
                playerCount: roomData.players.length,
                gameStarted: roomData.gameStarted || false,
                roundNumber: roomData.roundNumber || 0,
                title: roomData.title || 'ì´ˆì„± ë°°í‹€ë°©', // ğŸ†• ì œëª©ë„ metadataì— ì €ì¥
                gameMode: roomData.gameMode || 'time' // ğŸ†• ê²Œì„ ëª¨ë“œë„ metadataì— ì €ì¥
            }
        });
    } else {
        // ğŸ†• ê¸°ì¡´ í”Œë ˆì´ì–´ ì¬ì…ì¥: íƒˆë½ì ì¬ì…ì¥ ì²˜ë¦¬
        if (roomData.gameMode === 'turn' && roomData.gameStarted) {
            // í„´ì œ ëª¨ë“œì´ê³  ê²Œì„ì´ ì§„í–‰ ì¤‘ì´ë©´ DOì—ì„œ eliminatedPlayers í™•ì¸
            try {
                if (env.GAME_STATE) {
                    const id = env.GAME_STATE.idFromName(roomId);
                    const stub = env.GAME_STATE.get(id);
                    const stateRequest = new Request(`http://dummy/game-state?roomId=${roomId}`, {
                        method: 'GET'
                    });
                    const stateResponse = await stub.fetch(stateRequest);
                    if (stateResponse.ok) {
                        const doState = await stateResponse.json();
                        // íƒˆë½ìê°€ ì¬ì…ì¥í•˜ëŠ” ê²½ìš°: eliminatedPlayersì— ë‹¤ì‹œ ì¶”ê°€
                        if (doState.eliminatedPlayers && doState.eliminatedPlayers.includes(playerId)) {
                            // ì¬ì…ì¥ actionì„ DOì— ì „ì†¡í•˜ì—¬ eliminatedPlayersì— ë‹¤ì‹œ ì¶”ê°€
                            const rejoinRequest = new Request(`http://dummy/game-state?roomId=${roomId}`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    action: 'player_rejoin',
                                    playerId: playerId
                                })
                            });
                            await stub.fetch(rejoinRequest);
                            console.log(`[join-room] íƒˆë½ì ${playerId} ì¬ì…ì¥ - eliminatedPlayersì— ë‹¤ì‹œ ì¶”ê°€`);
                        }
                    }
                }
            } catch (e) {
                console.error('[join-room] íƒˆë½ì ì¬ì…ì¥ ì²˜ë¦¬ ì‹¤íŒ¨ (ë¬´ì‹œ):', e);
            }
        }
        
        // ê¸°ì¡´ í”Œë ˆì´ì–´ ì¬ì…ì¥ ì‹œ KV ì—…ë°ì´íŠ¸ (ë‹‰ë„¤ì„ ë³€ê²½ ë“±)
        existingPlayer.name = playerName || existingPlayer.name;
        existingPlayer.joinedAt = Date.now();
        
        await env.ROOM_LIST.put(roomId, JSON.stringify(roomData), {
            metadata: {
                id: roomId,
                roomNumber: roomData.roomNumber || 0,
                createdAt: roomData.createdAt,
                playerCount: roomData.players.length,
                gameStarted: roomData.gameStarted || false,
                roundNumber: roomData.roundNumber || 0,
                title: roomData.title || 'ì´ˆì„± ë°°í‹€ë°©',
                gameMode: roomData.gameMode || 'time'
            }
        });
    }

    return jsonResponse({ success: true, roomData });
}

async function handleLeaveRoom(request, env) {
    const { roomId, playerId } = await request.json();
    if (!roomId || !playerId) {
        return jsonResponse({ error: 'Missing parameters' }, 400);
    }

    const roomData = await env.ROOM_LIST.get(roomId, 'json');
    if (!roomData) {
        return jsonResponse({ error: 'Room not found' }, 404);
    }

    // ë°©ì¥ì¸ì§€ í™•ì¸ (ì²« ë²ˆì§¸ í”Œë ˆì´ì–´ê°€ ë°©ì¥)
    const wasHost = roomData.players.length > 0 && roomData.players[0].id === playerId;
    let newHostId = null;

    roomData.players = roomData.players.filter(p => p.id !== playerId);
    if (roomData.scores) delete roomData.scores[playerId];
    if (roomData.playerWords) delete roomData.playerWords[playerId];

    // ë°©ì¥ì´ ë‚˜ê°”ë‹¤ë©´ ìƒˆ ë°©ì¥ ì§€ì • (ë‚¨ì€ í”Œë ˆì´ì–´ ì¤‘ ì²« ë²ˆì§¸)
    if (wasHost && roomData.players.length > 0) {
        newHostId = roomData.players[0].id;
        // ë°©ì¥ ì •ë³´ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì €ì¥ (ì„ íƒì‚¬í•­)
        roomData.hostId = newHostId;
    }
    
    // ğŸ†• ë§ˆì§€ë§‰ í”Œë ˆì´ì–´ê¹Œì§€ ëª¨ë‘ ë‚˜ê°„ ê²½ìš°: ë°©ì„ ì¦‰ì‹œ ì‚­ì œí•˜ì—¬ ìœ ë ¹ë°© ìµœì†Œí™”
    if (roomData.players.length === 0) {
        try {
            // KVì—ì„œ ë°© í‚¤ ì‚­ì œ
            await env.ROOM_LIST.delete(roomId);

            // ìµœê·¼ ìƒì„±ëœ ë°© ëª©ë¡(_recent_rooms)ì—ì„œë„ ì œê±° (ìˆë‹¤ë©´)
            try {
                const recentRooms = await env.ROOM_LIST.get('_recent_rooms', 'json') || [];
                const filtered = recentRooms.filter(r => r.roomId !== roomId);
                if (filtered.length !== recentRooms.length) {
                    await env.ROOM_LIST.put('_recent_rooms', JSON.stringify(filtered));
                }
            } catch (e) {
                // recent_rooms ì •ë¦¬ëŠ” ì‹¤íŒ¨í•´ë„ ì¹˜ëª…ì ì´ì§€ ì•Šìœ¼ë¯€ë¡œ ë¡œê·¸ë§Œ ë‚¨ê¹€
                console.error('[leave-room] recent_rooms ì •ë¦¬ ì‹¤íŒ¨ (ë¬´ì‹œ):', e);
            }
        } catch (e) {
            console.error('[leave-room] ë§ˆì§€ë§‰ í”Œë ˆì´ì–´ í‡´ì¥ ì‹œ ë°© ì‚­ì œ ì‹¤íŒ¨:', e);
            // ë°© ì‚­ì œì— ì‹¤íŒ¨í•œ ê²½ìš°ë¥¼ ëŒ€ë¹„í•´, ê¸°ì¡´ put ë¡œì§ìœ¼ë¡œ í´ë°±
            await env.ROOM_LIST.put(roomId, JSON.stringify(roomData), {
                metadata: {
                    id: roomId,
                    roomNumber: roomData.roomNumber || 0,
                    createdAt: roomData.createdAt,
                    playerCount: roomData.players.length,
                    gameStarted: roomData.gameStarted || false,
                    roundNumber: roomData.roundNumber || 0,
                    title: roomData.title || 'ì´ˆì„± ë°°í‹€ë°©',
                    gameMode: roomData.gameMode || 'time'
                }
            });
        }
    } else {
        // ë‚¨ì€ í”Œë ˆì´ì–´ê°€ ìˆìœ¼ë©´ ê¸°ì¡´ëŒ€ë¡œ KV ì—…ë°ì´íŠ¸
        await env.ROOM_LIST.put(roomId, JSON.stringify(roomData), {
            metadata: {
                id: roomId,
                roomNumber: roomData.roomNumber || 0,
                createdAt: roomData.createdAt,
                playerCount: roomData.players.length,
                gameStarted: roomData.gameStarted || false,
                roundNumber: roomData.roundNumber || 0,
                title: roomData.title || 'ì´ˆì„± ë°°í‹€ë°©', // ğŸ†• ì œëª©ë„ metadataì— ì €ì¥
                gameMode: roomData.gameMode || 'time' // ğŸ†• ê²Œì„ ëª¨ë“œë„ metadataì— ì €ì¥
            }
        });
    }
    
    return jsonResponse({ 
        success: true, 
        remainingPlayers: roomData.players.length,
        newHostId: newHostId // ìƒˆ ë°©ì¥ ID ë°˜í™˜
    });
}

async function handleGameState(request, env) {
    const url = new URL(request.url);
    const roomId = url.searchParams.get('roomId');
    const pingPlayerId = url.searchParams.get('playerId') || null;
    if (!roomId) {
        return jsonResponse({ error: 'roomId is required' }, 400);
    }

    // GET ìš”ì²­: DO ìƒíƒœì™€ KVì˜ players ì •ë³´ë¥¼ ë³‘í•©
    if (request.method === 'GET') {
        // ë¨¼ì € KVì—ì„œ ê¸°ë³¸ ë°© ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        const roomData = await env.ROOM_LIST.get(roomId, 'json');
        if (!roomData) {
            return jsonResponse({ error: 'Room not found' }, 404);
        }

        // ğŸ†• í´ë§í•œ í”Œë ˆì´ì–´ì˜ lastSeen ê°±ì‹  (ì°½ì„ ê·¸ëƒ¥ ë‹«ì€ ê²½ìš°ë¥¼ ê°ì§€í•˜ê¸° ìœ„í•œ ìš©ë„)
        const now = Date.now();
        if (pingPlayerId) {
            if (!roomData.lastSeen) roomData.lastSeen = {};
            roomData.lastSeen[pingPlayerId] = now;

            try {
                await env.ROOM_LIST.put(roomId, JSON.stringify(roomData), {
                    metadata: {
                        id: roomId,
                        createdAt: roomData.createdAt,
                        playerCount: roomData.players?.length || 0,
                        gameStarted: roomData.gameStarted || false,
                        roundNumber: roomData.roundNumber || 0,
                        title: roomData.title || 'ì´ˆì„± ë°°í‹€ë°©',
                        gameMode: roomData.gameMode || 'time'
                    }
                });
            } catch (e) {
                console.error('[game-state] lastSeen ì—…ë°ì´íŠ¸ ì‹¤íŒ¨ (ë¬´ì‹œ):', e);
            }
        }

        let doState = null;
        
        // DO ë°”ì¸ë”©ì´ ìˆìœ¼ë©´ DOì—ì„œ ê²Œì„ ìƒíƒœ ê°€ì ¸ì˜¤ê¸°
        if (env.GAME_STATE) {
            try {
                const id = env.GAME_STATE.idFromName(roomId);
                const stub = env.GAME_STATE.get(id);
                const doResponse = await stub.fetch(request);
                
                if (doResponse.ok) {
                    doState = await doResponse.json();
                }
            } catch (error) {
                console.error(`[game-state] DO ì—ëŸ¬ (ë¬´ì‹œí•˜ê³  KV ë°ì´í„° ì‚¬ìš©):`, error);
            }
        }
        
        // DO ìƒíƒœê°€ ì—†ìœ¼ë©´ KV ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ê¸°ë³¸ ìƒíƒœ ìƒì„±
        if (!doState) {
            doState = {
                id: roomId,
                createdAt: roomData.createdAt,
                roomNumber: roomData.roomNumber || null,
                gameStarted: roomData.gameStarted || false,
                startTime: null,
                endTime: null,
                timeLeft: 180,
                consonants: [],
                scores: roomData.scores || {},
                playerWords: roomData.playerWords || {},
                roundNumber: roomData.roundNumber || 0,
                lastUpdate: null,
                chatMessages: [] // ì±„íŒ… ë©”ì‹œì§€ ì´ˆê¸°í™”
            };
        }
        
        // KVì˜ players ì •ë³´ì™€ ê¸°íƒ€ ë©”íƒ€ë°ì´í„° ë³‘í•©
        doState.players = roomData.players || [];
        doState.maxPlayers = roomData.maxPlayers || 5;
        doState.acceptingPlayers = roomData.acceptingPlayers !== false;
        doState.createdAt = roomData.createdAt;
        doState.roomNumber = roomData.roomNumber || doState.roomNumber || null;
        doState.title = roomData.title || 'ì´ˆì„± ë°°í‹€ë°©'; // ğŸ†• ì œëª© ì¶”ê°€
        doState.gameMode = roomData.gameMode || 'time'; // ğŸ†• ê²Œì„ ëª¨ë“œ ì¶”ê°€
        
        // ğŸ†• í„´ì œ ëª¨ë“œ ìƒíƒœ ë³‘í•©
        if (doState.gameMode === 'turn') {
            doState.currentTurnPlayerId = doState.currentTurnPlayerId || null;
            doState.turnStartTime = doState.turnStartTime || null;
            doState.playerLives = doState.playerLives || {};
            doState.eliminatedPlayers = doState.eliminatedPlayers || [];
            // ğŸ†• usedWordsëŠ” ì„œë²„ì—ì„œ ì „ì²´ ìœ ì§€í•˜ë˜, í´ë¼ì´ì–¸íŠ¸ë¡œëŠ” ìµœê·¼ 100ê°œë§Œ ì „ì†¡ (ë©”ëª¨ë¦¬ ì ˆì•½)
            // ì„œë²„ì—ì„œëŠ” ì¤‘ë³µ ì²´í¬ë¥¼ ìœ„í•´ ì „ì²´ë¥¼ ìœ ì§€í•˜ì§€ë§Œ (30000ê°œë“  ìƒê´€ì—†ì´), í´ë¼ì´ì–¸íŠ¸ëŠ” í™”ë©´ í‘œì‹œìš©ì´ë¯€ë¡œ ìµœê·¼ 100ê°œë§Œ í•„ìš”
            if (doState.usedWords && Array.isArray(doState.usedWords)) {
                doState.usedWords = doState.usedWords.slice(-100); // ìµœê·¼ 100ê°œë§Œ ì „ì†¡
            } else {
                doState.usedWords = [];
            }
            doState.turnCount = doState.turnCount || {};
            doState.isFirstTurn = doState.isFirstTurn !== undefined ? doState.isFirstTurn : true;
        }
        
        // DO ìƒíƒœê°€ ìˆìœ¼ë©´ DOë¥¼ ìš°ì„ , ì—†ìœ¼ë©´ KV ì‚¬ìš©
        // DOì˜ scoresì™€ KVì˜ scoresë¥¼ ë³‘í•© (DOê°€ ìš°ì„ , ì—†ìœ¼ë©´ KV ì‚¬ìš©)
        if (!doState.scores || Object.keys(doState.scores).length === 0) {
            // DOì— scoresê°€ ì—†ìœ¼ë©´ KVì˜ scores ì‚¬ìš©
            if (roomData.scores) {
                doState.scores = roomData.scores;
            }
        } else {
            // DOì— scoresê°€ ìˆìœ¼ë©´ DOë¥¼ ìš°ì„ í•˜ë˜, KVì˜ scoresë„ ë³‘í•© (ëˆ„ë½ëœ í”Œë ˆì´ì–´ ì ìˆ˜ ë³´ì™„)
            if (roomData.scores) {
                doState.scores = { ...roomData.scores, ...doState.scores };
            }
        }
        if (!doState.playerWords || Object.keys(doState.playerWords).length === 0) {
            // DOì— playerWordsê°€ ì—†ìœ¼ë©´ KVì˜ playerWords ì‚¬ìš©
            if (roomData.playerWords) {
                doState.playerWords = roomData.playerWords;
            }
        } else {
            // DOì— playerWordsê°€ ìˆìœ¼ë©´ DOë¥¼ ìš°ì„ í•˜ë˜, KVì˜ playerWordsë„ ë³‘í•©
            if (roomData.playerWords) {
                doState.playerWords = { ...roomData.playerWords, ...doState.playerWords };
            }
        }
        
        // chatMessagesê°€ ì—†ìœ¼ë©´ ë¹ˆ ë°°ì—´ë¡œ ì´ˆê¸°í™”
        if (!doState.chatMessages || !Array.isArray(doState.chatMessages)) {
            doState.chatMessages = [];
        }
        
        // playersê°€ ì—†ìœ¼ë©´ ë¹ˆ ë°°ì—´ë¡œ ì„¤ì • (ì—ëŸ¬ ë°©ì§€)
        if (!doState.players || !Array.isArray(doState.players)) {
            doState.players = [];
        }
        
        // ë””ë²„ê¹… ë¡œê·¸
        console.log(`[game-state] GET ${roomId}: players=${doState.players.length}, gameStarted=${doState.gameStarted}, chatMessages=${doState.chatMessages.length}`);
        
        return jsonResponse(doState);
    }
    
    // POST/DELETE ìš”ì²­: DOë¡œ ì „ë‹¬í•˜ê³ , ê²Œì„ ì•¡ì…˜ì´ë©´ KVë„ ì—…ë°ì´íŠ¸
    if (!env.GAME_STATE) {
        return jsonResponse({ error: 'Durable Object binding GAME_STATE missing' }, 500);
    }
    
    // POST ìš”ì²­ ë³¸ë¬¸ í™•ì¸ (cloneí•´ì„œ ì½ê¸°)
    let updateBody = null;
    if (request.method === 'POST') {
        const clonedRequest = request.clone();
        updateBody = await clonedRequest.json();
    }
    
    const id = env.GAME_STATE.idFromName(roomId);
    const stub = env.GAME_STATE.get(id);
    const doResponse = await stub.fetch(request);
    
    // ê²Œì„ ì•¡ì…˜ì´ë©´ KVë„ ì—…ë°ì´íŠ¸ (DOì™€ ë™ê¸°í™”)
    if (request.method === 'POST' && updateBody && updateBody.action) {
        try {
            const roomData = await env.ROOM_LIST.get(roomId, 'json');
            if (roomData) {
                if (updateBody.action === 'new_game') {
                    // new_game: scoresì™€ playerWords ì´ˆê¸°í™”
                    roomData.gameStarted = true;
                    roomData.roundNumber = (roomData.roundNumber || 0) + 1;
                    roomData.scores = {};
                    roomData.playerWords = {};
                } else if (updateBody.action === 'start_game') {
                    // start_game: ê²Œì„ ì‹œì‘
                    roomData.gameStarted = true;
                    roomData.roundNumber = (roomData.roundNumber || 0) + 1;
                } else if (updateBody.action === 'end_game') {
                    // end_game: ê²Œì„ ì¢…ë£Œ
                    roomData.gameStarted = false;
                }
                
                // KV ì—…ë°ì´íŠ¸
                await env.ROOM_LIST.put(roomId, JSON.stringify(roomData), {
                    metadata: {
                        id: roomId,
                        createdAt: roomData.createdAt,
                        playerCount: roomData.players?.length || 0,
                        gameStarted: roomData.gameStarted || false,
                        roundNumber: roomData.roundNumber || 0
                    }
                });
            }
        } catch (error) {
            console.error(`[game-state] KV ì—…ë°ì´íŠ¸ ì‹¤íŒ¨ (ë¬´ì‹œ):`, error);
        }
    }
    
    return doResponse;
}

async function handleChat(request, env) {
    const url = new URL(request.url);
    const roomId = url.searchParams.get('roomId');
    
    if (!roomId) {
        return jsonResponse({ error: 'roomId is required' }, 400);
    }

    if (!env.GAME_STATE) {
        return jsonResponse({ error: 'Durable Object binding GAME_STATE missing' }, 500);
    }

    const id = env.GAME_STATE.idFromName(roomId);
    const stub = env.GAME_STATE.get(id);

    if (request.method === 'POST') {
        const { playerName, message } = await request.json();
        
        if (!playerName || !message) {
            return jsonResponse({ error: 'Missing playerName or message' }, 400);
        }

        // DOì— ì±„íŒ… ë©”ì‹œì§€ ì „ë‹¬
        const chatRequest = new Request(`http://dummy/game-state?roomId=${roomId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chatMessage: message,
                playerId: url.searchParams.get('playerId') || 'unknown',
                playerName: playerName
            })
        });
        
        const response = await stub.fetch(chatRequest);
        return response;
    }

    if (request.method === 'GET') {
        // ì±„íŒ… ë©”ì‹œì§€ ì¡°íšŒ
        const stateRequest = new Request(`http://dummy/game-state?roomId=${roomId}`, {
            method: 'GET'
        });
        const stateResponse = await stub.fetch(stateRequest);
        const state = await stateResponse.json();
        
        // chatMessagesë§Œ ë°˜í™˜
        return jsonResponse(state.chatMessages || []);
    }

    return jsonResponse({ error: 'Method not allowed' }, 405);
}

async function handleValidateWord(request, env) {
    const corsHeaders = {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'POST, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type',
        'Content-Type': 'application/json'
    };

    if (request.method === 'OPTIONS') {
        return new Response(null, { headers: corsHeaders });
    }

    try {
        const { word } = await request.json();
        const trimmedWord = word.trim();
        
        // ğŸ†• KV ìºì‹œ í™•ì¸
        if (env.WORD_CACHE) {
            const cacheKey = `word:${trimmedWord}`;
            const cached = await env.WORD_CACHE.get(cacheKey, 'json');
            
            if (cached) {
                console.log(`[ìºì‹œ íˆíŠ¸] ${trimmedWord}`);
                return new Response(JSON.stringify(cached), { 
                    status: 200, 
                    headers: {
                        ...corsHeaders,
                        'X-Cache': 'HIT'
                    }
                });
            }
        }

        // API í˜¸ì¶œ
        const apiUrl = new URL('https://stdict.korean.go.kr/api/search.do');
        apiUrl.searchParams.append('key', 'C670DD254FE59C25E23DC785BA2AAAFE');
        apiUrl.searchParams.append('q', trimmedWord);
        apiUrl.searchParams.append('req_type', 'xml');

        const response = await fetch(apiUrl.toString());
        const xmlText = await response.text();

        // total í™•ì¸
        const totalMatch = xmlText.match(/<total>(\d+)<\/total>/);
        const total = totalMatch ? parseInt(totalMatch[1]) : 0;

        let result;
        
        if (total === 0) {
            result = {
                valid: false,
                error: 'ì‚¬ì „ì— ì—†ëŠ” ë‹¨ì–´ì…ë‹ˆë‹¤.',
                word: trimmedWord,
                definitions: [],
                length: trimmedWord.length
            };
        } else {
            // âœ… ëª¨ë“  XML íŒ¨í„´ ì‹œë„
            let definition = '';
            
            // íŒ¨í„´ 1: <definition>ë‚´ìš©</definition>
            let defMatch = xmlText.match(/<definition>([^<]+)<\/definition>/);
            if (!defMatch) {
                // íŒ¨í„´ 2: <definition><![CDATA[ë‚´ìš©]]></definition>
                defMatch = xmlText.match(/<definition><!\[CDATA\[([^\]]+)\]\]><\/definition>/);
            }
            if (!defMatch) {
                // íŒ¨í„´ 3: <definition>íƒœê·¸ í¬í•¨ ë‚´ìš©</definition>
                defMatch = xmlText.match(/<definition>([\s\S]*?)<\/definition>/);
            }

            if (defMatch) {
                definition = defMatch[1]
                    .replace(/<!\[CDATA\[(.*?)\]\]>/g, '$1')
                    .replace(/<[^>]*>/g, '')
                    .replace(/\s+/g, ' ')
                    .trim();
            }

            // í’ˆì‚¬ ì°¾ê¸°
            const posMatch = xmlText.match(/<pos>([^<]+)<\/pos>/);
            const pos = posMatch ? posMatch[1].trim() : '';

            // ëœ»ì´ ì—†ìœ¼ë©´
            if (!definition) {
                definition = 'âœ… ì‚¬ì „ ë“±ì¬ ë‹¨ì–´';
            }

            // ê¸¸ì´ ì œí•œ
            if (definition.length > 80) {
                definition = definition.substring(0, 77) + '...';
            }

            result = {
                valid: true,
                source: 'í‘œì¤€êµ­ì–´ëŒ€ì‚¬ì „',
                word: trimmedWord,
                definitions: [{
                    definition: definition,
                    pos: pos,
                    source: 'í‘œì¤€êµ­ì–´ëŒ€ì‚¬ì „'
                }],
                length: trimmedWord.length
            };
        }
        
        // ğŸ†• KV ìºì‹œ ì €ì¥ (30ì¼ TTL)
        if (env.WORD_CACHE) {
            const cacheKey = `word:${trimmedWord}`;
            try {
                await env.WORD_CACHE.put(cacheKey, JSON.stringify(result), {
                    expirationTtl: 30 * 24 * 60 * 60 // 30ì¼
                });
                console.log(`[ìºì‹œ ì €ì¥] ${trimmedWord}`);
            } catch (cacheError) {
                console.error(`[ìºì‹œ ì €ì¥ ì‹¤íŒ¨] ${trimmedWord}:`, cacheError);
                // ìºì‹œ ì €ì¥ ì‹¤íŒ¨í•´ë„ ê²°ê³¼ëŠ” ë°˜í™˜
            }
        }

        return new Response(JSON.stringify(result), { 
            status: 200, 
            headers: {
                ...corsHeaders,
                'X-Cache': 'MISS'
            }
        });

    } catch (error) {
        return new Response(JSON.stringify({
            valid: false,
            error: 'ì‚¬ì „ ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜',
            message: error.message
        }), { status: 500, headers: corsHeaders });
    }
}

function generateRoomCode() {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    let code = '';
    for (let i = 0; i < 4; i++) {
        code += chars[Math.floor(Math.random() * chars.length)];
    }
    return code;
}

function jsonResponse(payload, status = 200) {
    return new Response(JSON.stringify(payload), {
        status,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
}

// ============================================
// Main Worker Export
// ============================================

export default {
    async fetch(request, env, ctx) {
        const url = new URL(request.url);

        if (request.method === 'OPTIONS') {
            return new Response(null, { headers: corsHeaders });
        }

        if (url.pathname === '/api/rooms' && request.method === 'GET') {
            return handleRooms(env);
        }

        if (url.pathname === '/api/create-room' && request.method === 'POST') {
            return handleCreateRoom(request, env);
        }

        if (url.pathname === '/api/join-room' && request.method === 'POST') {
            return handleJoinRoom(request, env);
        }

        if (url.pathname === '/api/leave-room' && request.method === 'POST') {
            return handleLeaveRoom(request, env);
        }

        if (url.pathname === '/api/game-state') {
            return handleGameState(request, env);
        }

        if (url.pathname === '/api/validate-word' && request.method === 'POST') {
            return handleValidateWord(request, env);
        }

        if (url.pathname === '/api/chat') {
            return handleChat(request, env);
        }

        // API ì „ìš© Worker - ì •ì  íŒŒì¼ì€ Vercelì—ì„œ ì„œë¹™
        // API ë¼ìš°íŠ¸ê°€ ì•„ë‹Œ ê²½ìš° 404 ë°˜í™˜
        return new Response('API only - Static files served by Vercel', { 
            status: 404,
            headers: { 'Content-Type': 'text/plain' }
        });
    }
};

